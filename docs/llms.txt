# marimo-dev

> Build and publish python packages from marimo notebooks

Version: 0.2.1

## API

```python
class Config:
    nbs: str
    out: str
    docs: str
    root: str
    decorators: list[str]
    skip_prefixes: list[str]

def read_config(
    root='.'
):
    """Read config from pyproject.toml [tool.marimo-dev] section with defaults"""

class Kind:
    """Types of nodes in parsed code"""

class Param:
    name: str  # parameter name
    anno: str | None  # type annotation
    default: str | None  # default value
    doc: str

class Node:
    """A parsed code node representing an import, constant, or exported function/class."""
    kind: Kind
    name: str
    src: str
    doc: str
    params: list[Param]
    methods: list
    ret: tuple[str, str] | None
    hash_pipes: list[str]
    module: str
    lineno: int

def inline_doc(
    ls: list[str],  # source code lines
    ln: int,  # line number to search
    name: str  # identifier name to match before comment
) -> str:
    """Extract inline comment following an identifier on a source line."""

def parse_params(
    fn,  # function node to extract parameters from
    ls  # source lines for inline doc extraction
) -> list[Param]:
    """Extract parameters from a function node with inline documentation."""

def parse_hash_pipe(
    ls: list,  # source code lines
    export_dec  # the export decorator node
) -> list[str]:
    """Extract hash pipe directives from line immediately after export decorator"""

class parse_class_params:
    """Extract parameters from __init__ method if present, else class attributes."""
    n: ast.ClassDef  # class node to extract params from
    ls: list  # source lines for inline doc extraction

class parse_class_methods:
    """Extract methods from a class definition."""
    n: ast.ClassDef
    ls: list

def parse_ret(
    fn,  # function node to parse return annotation from
    ls  # source code lines
) -> tuple[str, str] | None:
    """Extract return type annotation and inline documentation from function node."""

def src_with_decs(
    n,  # AST node with potential decorators
    ls  # source code lines
) -> str:
    """Extract source code including decorators from AST node."""

def is_export(
    d,  # decorator node to check
    cfg: Config  # configuration object
) -> bool:
    """Check if decorator marks a node for export."""

def parse_import(
    n: ast.AST,  # AST node to check
    ls: list  # source lines (unused but kept for consistent interface)
) -> Node | None:
    """Extract import node from AST."""

def parse_const(
    n: ast.AST,  # AST node to check
    ls: list  # source lines (unused)
) -> Node | None:
    """Extract constant definition from assignment."""

class parse_export:
    """Extract exported function or class decorated with export decorators from config."""
    n: ast.AST  # AST node to check
    ls: list  # source lines for inline doc and decorators
    cfg: Config  # configuration object

def parse_node(
    n: ast.AST,  # AST node to parse
    src: str,  # full source code text
    cfg: Config  # configuration object
):
    """Extract importable nodes from an AST node."""

def parse_file(
    p: str | Path,  # path to Python file to parse
    module: str='',  # module name to assign to nodes
    root: str='.'  # root directory containing pyproject.toml
) -> list[Node]:
    """Parse a Python file and extract all nodes."""

def read_meta(
    root='.'  # project root directory containing pyproject.toml
) -> dict:
    """Read project metadata from pyproject.toml."""

def nb_name(
    f: Path,  # file path to extract notebook name from
    root: str='.'  # root directory containing pyproject.toml
) -> str | None:
    """Extract notebook name from file path, skipping hidden, test, and configured prefix files."""

def scan(
    root='.'  # root directory containing pyproject.toml
):
    """Scan notebooks directory and extract metadata and module definitions."""

def clean(
    src: str  # source code to clean
) -> str:
    """Remove decorator and hash pipe lines from source code"""

def write(
    p: str  # path to write to
):
    """Write parts to file, filtering None values and joining with blank lines."""

def write_mod(
    path,  # output file path
    nodes: list,  # list of Node objects to write
    mod_names: list  # list of module names for import rewriting
):
    """Write module file with imports, constants, and exports."""

def rewrite_imports(
    src: str,  # source code to rewrite
    mod_names: list  # list of module names
) -> str:
    """Rewrite cross-notebook imports to relative package imports"""

def write_init(
    path: str | Path,  # path to write __init__.py file
    meta: dict,  # metadata dict with desc, version, author
    mods: list  # list of (name nodes) tuples
):
    """Generate and write __init__.py file with metadata and exports."""

class cls_sig:
    """Generate a class signature string."""
    n: Node  # the node to generate signature for
    dataclass = False  # whether to include @dataclass decorator

def fn_sig(
    n: Node,  # the node to generate signature for
    is_async=False  # async ?
) -> str:
    """Generate a function signature string with inline parameter documentation."""

class sig:
    """Generate a signature string for a class or function node."""
    n: Node  # the node to generate signature for

def write_llms(
    meta: dict,  # project metadata from pyproject.toml
    nodes: list,  # list of Node objects to document
    root: str='.'  # root directory containing pyproject.toml
):
    """Write API signatures to llms.txt file for LLM consumption."""

class exp_type:
    n

def render_param(
    p
):

def nb_path(
    mod_name,
    root='.'
):
    """[TODO] """

def render_node(
    n,
    repo_url=None,
    root='.'
):
    """Builds a `node` for docs"""

def render_module_page(
    mod_name,
    mod_nodes,
    all_mod_names,
    meta,
    root='.'
):
    """Builds a Module Page"""

def build_docs(
    root='.'  # the project root (this should never really change)
):
    """Builds the static documentation website"""

def export_wasm(
    root='.'
):

def write_nojekyll(
    root='.'
):

def html_preview(
    width='100%',
    height='300px'
):
    """Display FT components in an IFrame"""

def render_index_page(
    meta,
    mods,
    repo_url=None
):

def Icon(
    name: str,  # name of the icon MUST be in icon_dict
    size=24,  # value to be passed to height and width of the icon
    stroke=1.5,  # stroke width
    icon_dict: dict=icons  # Dict of icons {"name":"<svg...>"}
):
    """Creates a custom html compliant <icon-{name}>... 
Intended to be used with a Global Dict of icons {"home": "<svg...", "info": "<svg..."} 
Icon('home') -> <icon-home> ....  </icon-home>"""

def build(
    root='.'  # root directory containing pyproject.toml
) -> str:
    """Build a Python package from notebooks."""

def tidy():
    """Remove cache and temporary files (__pycache__, __marimo__, .pytest_cache, etc)."""

def nuke():
    """Remove all build artifacts (dist, docs, src) and cache files."""

def publish(
    test: bool=True  # Use Test PyPI if True real PyPI if False
):
    """Build and publish package to PyPI. Looks for ~/.pypirc for credentials, otherwise prompts."""

def main():
```