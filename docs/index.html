<!doctype html>
<html>
  <head>
    <title>docs</title>
<script type="module" src="https://cdn.jsdelivr.net/gh/starfederation/datastar@1.0.0-RC.6/bundles/datastar.js"></script>    <style>
      * {
        scrollbar-gutter: stable;
      }
      body{
        font-family:sans-serif;
        max-width:1400px;
        margin:1rem auto;
        padding:0 1rem;
        line-height:1.5;
      }
      .header{
        display:flex;
        justify-content:space-between;
        align-items:flex-start;
        margin-bottom:1rem;
        gap:2rem;
      }
      .title-section{
        flex:1;
      }
      .search-section{
        position:fixed;
        top:1rem;
        right:1rem;
        z-index:100;
        display:flex;
        gap:0.5rem;
        align-items:center;
        background:white;
        padding:0.75rem;
        border-radius:0.5rem;
        box-shadow:0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
      }
      .content-wrapper{
        display:grid;
        grid-template-columns:250px 1fr;
        gap:2rem;
      }
      .main-content{
        min-width:0;
      }
      .sidenav{
        position:sticky;
        top:1rem;
        height:fit-content;
        max-height:calc(100vh - 2rem);
        overflow-y:auto;
        padding:1rem;
        background:#f9fafb;
        border-radius:0.375rem;
        border:1px solid #e5e7eb;
      }
      .sidenav h3{
        margin:0 0 0.75rem 0;
        font-size:0.875rem;
        font-weight:600;
        color:#6b7280;
        text-transform:uppercase;
      }
      .nav-item{
        display:flex;
        align-items:center;
        justify-content:space-between;
        padding:0.5rem;
        margin-bottom:0.25rem;
        border-radius:0.25rem;
        font-size:0.875rem;
        color:#374151;
        text-decoration:none;
        transition:all 0.15s;
      }
      .nav-item:hover{
        background:#e5e7eb;
      }
      .nav-item.disabled{
        opacity:0.4;
        cursor:not-allowed;
        pointer-events:none;
      }
      .nav-badge{
        background:#3b82f6;
        color:white;
        padding:0.125rem 0.5rem;
        border-radius:9999px;
        font-size:0.7rem;
        font-weight:600;
        min-width:1.5rem;
        text-align:center;
      }
      .attribute-name{font-weight:bold;font-size:1.25rem;margin-bottom:0.25rem;color:#1e40af}
      .description{margin:0.5rem 0;color:#374151;font-size:0.9rem}
      .attributes{display:flex;flex-direction:column;gap:1rem}
      .attribute{
        position:relative;
        padding:1rem;
        border:1px solid #e5e7eb;
        border-radius:0.375rem;
        background:#fff;
        scroll-margin-top:3rem;
        transition: order 0.5s cubic-bezier(0.4, 0, 0.2, 1), 
                    transform 0.5s cubic-bezier(0.4, 0, 0.2, 1),
                    opacity 0.3s ease-in-out;
      }
      .attribute:hover{box-shadow:0 2px 4px rgba(0,0,0,0.1)}
      input{padding:0.625rem;border:1px solid #d1d5db;border-radius:0.375rem;min-width:250px;font-size:0.95rem}
      input:focus{outline:2px solid #3b82f6;outline-offset:0}
      .debug{
        margin-bottom:1rem;
        padding:0.75rem;
        background:#f3f4f6;
        font-family:monospace;
        font-size:0.8rem;
        border-radius:0.375rem;
        display:flex;
        justify-content:space-between;
        align-items:center;
        gap:1rem;
      }
      .debug-info{
        flex:1;
      }
      .match-badge{
        position:absolute;
        top:1rem;
        right:1rem;
        background:#3b82f6;
        color:white;
        padding:0.25rem 0.75rem;
        border-radius:9999px;
        font-size:0.8rem;
        font-weight:600;
      }
      button{
        padding:0.625rem 1.25rem;
        background:#3b82f6;
        color:white;
        border:none;
        border-radius:0.375rem;
        cursor:pointer;
        font-size:0.95rem;
        transition:background 0.15s;
        white-space:nowrap;
      }
      button:hover{background:#2563eb}
      button:active{background:#1d4ed8}
      button.clear-btn{
        background:#dc2626;
      }
      button.clear-btn:hover{
        background:#b91c1c;
      }
      code{background:#f3f4f6;color:#1f2937;padding:0.125rem 0.375rem;border-radius:0.25rem;font-size:0.85rem;font-family:monospace}
      h1{color:#111827;margin:0 0 0.25rem 0;font-size:1.75rem}
      .subtitle{color:#6b7280;margin:0;font-size:0.9rem}
      pre{background:#1f2937;color:#f9fafb;padding:0.75rem;border-radius:0.375rem;overflow-x:auto;font-size:0.8rem;margin:0.375rem 0}
      pre code{background:transparent;color:#f9fafb;padding:0}
      </style>
  </head>
  <body>
    <body data-signals="{ search: '', tags: [] }">
<form data-on:submit__prevent="$search.trim() ? ($tags = [...$tags, $search.trim()], $search = '') : null" class="search-section">        <input type="text" placeholder="Live Search ...(enter to add tag)" data-bind:search>
<button type="submit">Add Tag</button><button type="button" data-on:click="$tags = [], $search = ''" class="clear-btn">Clear All</button></form>      <div class="title-section">
        <h1>m_dev.core ‚Äî Interactive Docs</h1>
      </div>
      <div class="debug">
        <div class="debug-info">
Tags: <span data-text="JSON.stringify($tags)">[]</span><br>Search: <span data-text="$search"></span>        </div>
<button type="button" data-on:click="$tags = [], $search = ''" class="clear-btn">Clear All</button>      </div>
      <div class="content-wrapper">
        <aside class="sidenav">
          <h3>Functions</h3>
<a href="#add" data-class:disabled="($tags.length > 0 || $search.trim().length > 0) && $matchCount0 === 0" class="nav-item"><span>add</span><span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount0" class="nav-badge" style="display: none;">0</span></a><a href="#build_formatted_docstring" data-class:disabled="($tags.length > 0 || $search.trim().length > 0) && $matchCount1 === 0" class="nav-item"><span>build_formatted_docstring</span><span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount1" class="nav-badge" style="display: none;">0</span></a><a href="#build_package" data-class:disabled="($tags.length > 0 || $search.trim().length > 0) && $matchCount2 === 0" class="nav-item"><span>build_package</span><span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount2" class="nav-badge" style="display: none;">0</span></a><a href="#convert_docstyle" data-class:disabled="($tags.length > 0 || $search.trim().length > 0) && $matchCount3 === 0" class="nav-item"><span>convert_docstyle</span><span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount3" class="nav-badge" style="display: none;">0</span></a><a href="#extract_all_mo_md" data-class:disabled="($tags.length > 0 || $search.trim().length > 0) && $matchCount4 === 0" class="nav-item"><span>extract_all_mo_md</span><span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount4" class="nav-badge" style="display: none;">0</span></a><a href="#extract_exports" data-class:disabled="($tags.length > 0 || $search.trim().length > 0) && $matchCount5 === 0" class="nav-item"><span>extract_exports</span><span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount5" class="nav-badge" style="display: none;">0</span></a><a href="#extract_mo_md_content" data-class:disabled="($tags.length > 0 || $search.trim().length > 0) && $matchCount6 === 0" class="nav-item"><span>extract_mo_md_content</span><span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount6" class="nav-badge" style="display: none;">0</span></a><a href="#extract_param_docs_from_ast" data-class:disabled="($tags.length > 0 || $search.trim().length > 0) && $matchCount7 === 0" class="nav-item"><span>extract_param_docs_from_ast</span><span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount7" class="nav-badge" style="display: none;">0</span></a><a href="#extract_readme" data-class:disabled="($tags.length > 0 || $search.trim().length > 0) && $matchCount8 === 0" class="nav-item"><span>extract_readme</span><span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount8" class="nav-badge" style="display: none;">0</span></a><a href="#format_docments_style" data-class:disabled="($tags.length > 0 || $search.trim().length > 0) && $matchCount9 === 0" class="nav-item"><span>format_docments_style</span><span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount9" class="nav-badge" style="display: none;">0</span></a><a href="#format_google_style" data-class:disabled="($tags.length > 0 || $search.trim().length > 0) && $matchCount10 === 0" class="nav-item"><span>format_google_style</span><span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount10" class="nav-badge" style="display: none;">0</span></a><a href="#format_numpy_style" data-class:disabled="($tags.length > 0 || $search.trim().length > 0) && $matchCount11 === 0" class="nav-item"><span>format_numpy_style</span><span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount11" class="nav-badge" style="display: none;">0</span></a><a href="#is_marimo_export_decorator" data-class:disabled="($tags.length > 0 || $search.trim().length > 0) && $matchCount12 === 0" class="nav-item"><span>is_marimo_export_decorator</span><span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount12" class="nav-badge" style="display: none;">0</span></a><a href="#old_write_init" data-class:disabled="($tags.length > 0 || $search.trim().length > 0) && $matchCount13 === 0" class="nav-item"><span>old_write_init</span><span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount13" class="nav-badge" style="display: none;">0</span></a><a href="#scan_notebooks" data-class:disabled="($tags.length > 0 || $search.trim().length > 0) && $matchCount14 === 0" class="nav-item"><span>scan_notebooks</span><span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount14" class="nav-badge" style="display: none;">0</span></a><a href="#update_pyproject_toml" data-class:disabled="($tags.length > 0 || $search.trim().length > 0) && $matchCount15 === 0" class="nav-item"><span>update_pyproject_toml</span><span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount15" class="nav-badge" style="display: none;">0</span></a><a href="#validate_setup_metadata" data-class:disabled="($tags.length > 0 || $search.trim().length > 0) && $matchCount16 === 0" class="nav-item"><span>validate_setup_metadata</span><span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount16" class="nav-badge" style="display: none;">0</span></a><a href="#write_init" data-class:disabled="($tags.length > 0 || $search.trim().length > 0) && $matchCount17 === 0" class="nav-item"><span>write_init</span><span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount17" class="nav-badge" style="display: none;">0</span></a><a href="#write_module" data-class:disabled="($tags.length > 0 || $search.trim().length > 0) && $matchCount18 === 0" class="nav-item"><span>write_module</span><span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount18" class="nav-badge" style="display: none;">0</span></a>        </aside>
        <div class="main-content">
          <div class="attributes">
            <div data-signals="{ searchable0: 'add m_dev.core a b return add `a` to `b`

returns:
    int: the result is calculated using python's builtin `+` operator.', matchCount0: 0 }" data-effect="$matchCount0 = [...$tags, $search.trim()].filter(t => t && $searchable0.includes(t.toLowerCase())).length" data-show="($tags.length === 0 && $search.trim().length === 0) || $matchCount0 > 0" data-style-order="($tags.length === 0 && $search.trim().length === 0) ? 0 : -$matchCount0" id="add" class="attribute">
<span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount0" class="match-badge" style="display:none;">0</span>              <div class="func-header-right">
<span class="func-module">m_dev.core</span>              </div>
>      add (a:int, b:int)

*Add `a` to `b`*

Returns:
    int: The result is calculated using Python's builtin `+` operator.<details><summary style="cursor:pointer; margin-top:1rem; color:#2563eb">Source code</summary><pre><code>def add(a: int, b: int) -&gt; int:
    """Add `a` to `b`

Returns:
    int: The result is calculated using Python's builtin `+` operator."""
    return a + b
</code></pre></details>            </div>
            <div data-signals="{ searchable1: 'build_formatted_docstring m_dev.core func_source docs target_style return build formatted docstring from docs dict

args:
    func_source (str): original function source code
    docs (dict): parameter docs from extract_param_docs_from_ast
    target_style (str): 'google' or 'numpy'

returns:
    str: function source with reformatted docstring', matchCount1: 0 }" data-effect="$matchCount1 = [...$tags, $search.trim()].filter(t => t && $searchable1.includes(t.toLowerCase())).length" data-show="($tags.length === 0 && $search.trim().length === 0) || $matchCount1 > 0" data-style-order="($tags.length === 0 && $search.trim().length === 0) ? 1 : -$matchCount1" id="build_formatted_docstring" class="attribute">
<span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount1" class="match-badge" style="display:none;">0</span>              <div class="func-header-right">
<span class="func-module">m_dev.core</span>              </div>
>      build_formatted_docstring (func_source:str, docs:dict, target_style:str)

*Build formatted docstring from docs dict*

Args:
    func_source (str): Original function source code
    docs (dict): Parameter docs from extract_param_docs_from_ast
    target_style (str): 'google' or 'numpy'

Returns:
    str: Function source with reformatted docstring<details><summary style="cursor:pointer; margin-top:1rem; color:#2563eb">Source code</summary><pre><code>def build_formatted_docstring(func_source: str, docs: dict, target_style: str) -&gt; str:
    """Build formatted docstring from docs dict

Args:
    func_source (str): Original function source code
    docs (dict): Parameter docs from extract_param_docs_from_ast
    target_style (str): 'google' or 'numpy'

Returns:
    str: Function source with reformatted docstring"""
    tree = ast.parse(func_source)
    func_node = tree.body[0]
    existing_doc = ast.get_docstring(func_node) or ''
    lines = [existing_doc.strip()] if existing_doc else []
    if target_style == 'google':
        params = {k: v for k, v in docs.items() if k != 'return' and v.get('docment')}
        if params:
            lines.append('')
            lines.append('Args:')
            for name, info in params.items():
                anno = info.get('anno', '')
                doc = info.get('docment', '')
                if anno:
                    lines.append(f'    {name} ({anno}): {doc}')
                else:
                    lines.append(f'    {name}: {doc}')
        ret = docs.get('return')
        if ret and ret.get('docment'):
            lines.append('')
            lines.append('Returns:')
            ret_anno = ret.get('anno', '')
            ret_doc = ret.get('docment', '')
            if ret_anno:
                lines.append(f'    {ret_anno}: {ret_doc}')
            else:
                lines.append(f'    {ret_doc}')
    elif target_style == 'numpy':
        params = {k: v for k, v in docs.items() if k != 'return' and v.get('docment')}
        if params:
            lines.append('')
            lines.append('Parameters')
            lines.append('----------')
            for name, info in params.items():
                anno = info.get('anno', '')
                doc = info.get('docment', '')
                if anno:
                    lines.append(f'{name} : {anno}')
                else:
                    lines.append(f'{name}')
                if doc:
                    lines.append(f'    {doc}')
        ret = docs.get('return')
        if ret and ret.get('docment'):
            lines.append('')
            lines.append('Returns')
            lines.append('-------')
            ret_anno = ret.get('anno', '')
            ret_doc = ret.get('docment', '')
            if ret_anno:
                lines.append(f'{ret_anno}')
            if ret_doc:
                lines.append(f'    {ret_doc}')
    new_docstring = '\n'.join(lines)
    for node in ast.walk(tree):
        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
            if node.body and isinstance(node.body[0], ast.Expr) and isinstance(node.body[0].value, ast.Constant):
                node.body[0].value.value = new_docstring
            else:
                doc_node = ast.Expr(value=ast.Constant(value=new_docstring))
                node.body.insert(0, doc_node)
            break
    return ast.unparse(tree)
</code></pre></details>            </div>
            <div data-signals="{ searchable2: 'build_package m_dev.core notebooks_dir output_dir docstring_style return build a python package from marimo notebook(s)

args:
    notebooks_dir (str): directory with notebook files
    output_dir (str): output directory for package
    docstring_style (str): docstring format

returns:
    str: path to built package', matchCount2: 0 }" data-effect="$matchCount2 = [...$tags, $search.trim()].filter(t => t && $searchable2.includes(t.toLowerCase())).length" data-show="($tags.length === 0 && $search.trim().length === 0) || $matchCount2 > 0" data-style-order="($tags.length === 0 && $search.trim().length === 0) ? 2 : -$matchCount2" id="build_package" class="attribute">
<span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount2" class="match-badge" style="display:none;">0</span>              <div class="func-header-right">
<span class="func-module">m_dev.core</span>              </div>
>      build_package (notebooks_dir:str='notebooks', output_dir:str='src',
>                     docstring_style:str='nbdev')

*Build a Python package from marimo notebook(s)*

Args:
    notebooks_dir (str): Directory with notebook files
    output_dir (str): Output directory for package
    docstring_style (str): Docstring format

Returns:
    str: Path to built package<details><summary style="cursor:pointer; margin-top:1rem; color:#2563eb">Source code</summary><pre><code>def build_package(notebooks_dir: str='notebooks', output_dir: str='src', docstring_style: str='nbdev') -&gt; str:
    """Build a Python package from marimo notebook(s)

Args:
    notebooks_dir (str): Directory with notebook files
    output_dir (str): Output directory for package
    docstring_style (str): Docstring format

Returns:
    str: Path to built package"""
    print(f'üîç Scanning notebooks in {notebooks_dir}/')
    scan_result = scan_notebooks(notebooks_dir, docstring_style)
    metadata = scan_result['metadata']
    modules = scan_result['modules']
    index_path = scan_result['index_path']
    package_name = metadata.get('__package_name__')
    if not package_name:
        try:
            import tomllib
            with open('pyproject.toml', 'rb') as f:
                config = tomllib.load(f)
                package_name = config['project']['name']
        except:
            raise ValueError('No __package_name__ in metadata and no pyproject.toml found')
    package_name = package_name.replace('-', '_')
    print(f'üì¶ Building package: {package_name}')
    package_dir = Path(output_dir) / package_name
    package_dir.mkdir(parents=True, exist_ok=True)
    for module in modules:
        if module['name'] == 'index':
            continue
        if module['exports']:
            module_file = package_dir / f"{module['name']}.py"
            write_module(module['name'], module['imports'], module['exports'], str(module_file))
            print(f"  ‚úÖ {module['name']}.py")
    init_file = package_dir / '__init__.py'
    write_init(package_name, metadata, modules, str(init_file))
    if Path('pyproject.toml').exists():
        update_pyproject_toml(metadata, 'pyproject.toml')
    else:
        print("‚ö†Ô∏è  No pyproject.toml found. Run 'uv init' first.")
    extract_readme(metadata, index_path)
    print(f'\n‚úÖ Package built in {output_dir}/{package_name}/')
    return str(output_dir)
</code></pre></details>            </div>
            <div data-signals="{ searchable3: 'convert_docstyle m_dev.core func target_style include_signature return convert function documentation between different styles.

args:
    func: the function to convert documentation for
    target_style: one of 'docments', 'google', or 'numpy'
    include_signature: whether to include the function signature

returns:
    str: string representation in the target documentation style', matchCount3: 0 }" data-effect="$matchCount3 = [...$tags, $search.trim()].filter(t => t && $searchable3.includes(t.toLowerCase())).length" data-show="($tags.length === 0 && $search.trim().length === 0) || $matchCount3 > 0" data-style-order="($tags.length === 0 && $search.trim().length === 0) ? 3 : -$matchCount3" id="convert_docstyle" class="attribute">
<span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount3" class="match-badge" style="display:none;">0</span>              <div class="func-header-right">
<span class="func-module">m_dev.core</span>              </div>
>      convert_docstyle (func, target_style='google', include_signature=True)

*Convert function documentation between different styles.*

Args:
    func: The function to convert documentation for
    target_style: One of 'docments', 'google', or 'numpy'
    include_signature: Whether to include the function signature

Returns:
    str: String representation in the target documentation style<details><summary style="cursor:pointer; margin-top:1rem; color:#2563eb">Source code</summary><pre><code>def convert_docstyle(func, target_style='google', include_signature=True) -&gt; str:
    """Convert function documentation between different styles.

Args:
    func: The function to convert documentation for
    target_style: One of 'docments', 'google', or 'numpy'
    include_signature: Whether to include the function signature

Returns:
    str: String representation in the target documentation style"""
    docs_full = docments(func, full=True)
    main_doc = docstring(func)
    func_name = func.__name__
    sig = inspect.signature(func)
    params = {k: v for k, v in docs_full.items() if k != 'return'}
    return_info = docs_full.get('return', {})
    if target_style == 'docments':
        return format_docments_style(func_name, params, return_info, main_doc, include_signature)
    elif target_style == 'google':
        return format_google_style(func_name, params, return_info, main_doc, include_signature, sig)
    elif target_style == 'numpy':
        return format_numpy_style(func_name, params, return_info, main_doc, include_signature, sig)
    else:
        raise ValueError(f"Unknown style: {target_style}. Use 'docments', 'google', or 'numpy'")
</code></pre></details>            </div>
            <div data-signals="{ searchable4: 'extract_all_mo_md m_dev.core source return extract all mo.md() content from source

returns:
    list: returns list of strings', matchCount4: 0 }" data-effect="$matchCount4 = [...$tags, $search.trim()].filter(t => t && $searchable4.includes(t.toLowerCase())).length" data-show="($tags.length === 0 && $search.trim().length === 0) || $matchCount4 > 0" data-style-order="($tags.length === 0 && $search.trim().length === 0) ? 4 : -$matchCount4" id="extract_all_mo_md" class="attribute">
<span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount4" class="match-badge" style="display:none;">0</span>              <div class="func-header-right">
<span class="func-module">m_dev.core</span>              </div>
>      extract_all_mo_md (source:str)

*Extract all mo.md() content from source*

Returns:
    list: Returns list of strings<details><summary style="cursor:pointer; margin-top:1rem; color:#2563eb">Source code</summary><pre><code>def extract_all_mo_md(source: str) -&gt; list:
    """Extract all mo.md() content from source

Returns:
    list: Returns list of strings"""
    pattern = 'mo\\.md\\s*\\(\\s*[rf]*"""(.*?)"""|mo\\.md\\s*\\(\\s*[rf]*\\\'\\\'\\\'(.*?)\\\'\\\'\\\'|mo\\.md\\s*\\(\\s*[rf]*"(.*?)"|mo\\.md\\s*\\(\\s*[rf]*\\\'(.*?)\\\''
    results = []
    for match in re.finditer(pattern, source, re.DOTALL):
        for i in range(1, len(match.groups()) + 1):
            if match.group(i) is not None:
                results.append(match.group(i))
    return results
</code></pre></details>            </div>
            <div data-signals="{ searchable5: 'extract_exports m_dev.core notebook_path docstring_style return extract metadata, imports, and exportable functions/classes from marimo notebook

args:
    notebook_path (str): path to marimo notebook file
    docstring_style (str): target docstring format: 'google', 'numpy', or 'nbdev'

returns:
    tuple: (setup_metadata, setup_imports, exports, export_names)', matchCount5: 0 }" data-effect="$matchCount5 = [...$tags, $search.trim()].filter(t => t && $searchable5.includes(t.toLowerCase())).length" data-show="($tags.length === 0 && $search.trim().length === 0) || $matchCount5 > 0" data-style-order="($tags.length === 0 && $search.trim().length === 0) ? 5 : -$matchCount5" id="extract_exports" class="attribute">
<span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount5" class="match-badge" style="display:none;">0</span>              <div class="func-header-right">
<span class="func-module">m_dev.core</span>              </div>
>      extract_exports (notebook_path:str, docstring_style:str='nbdev')

*Extract metadata, imports, and exportable functions/classes from marimo notebook*

Args:
    notebook_path (str): Path to marimo notebook file
    docstring_style (str): Target docstring format: 'google', 'numpy', or 'nbdev'

Returns:
    tuple: (setup_metadata, setup_imports, exports, export_names)<details><summary style="cursor:pointer; margin-top:1rem; color:#2563eb">Source code</summary><pre><code>def extract_exports(notebook_path: str, docstring_style: str='nbdev') -&gt; tuple:
    """Extract metadata, imports, and exportable functions/classes from marimo notebook

Args:
    notebook_path (str): Path to marimo notebook file
    docstring_style (str): Target docstring format: 'google', 'numpy', or 'nbdev'

Returns:
    tuple: (setup_metadata, setup_imports, exports, export_names)"""
    source_code = Path(notebook_path).read_text()
    tree = ast.parse(source_code)
    setup_metadata = {}
    setup_imports = []
    exports = []
    export_names = []
    for node in tree.body:
        if isinstance(node, ast.With):
            for stmt in node.body:
                if isinstance(stmt, ast.Assign):
                    setup_metadata[stmt.targets[0].id] = ast.literal_eval(stmt.value)
                elif isinstance(stmt, (ast.Import, ast.ImportFrom)):
                    setup_imports.append(ast.unparse(stmt))
        elif isinstance(node, (ast.FunctionDef, ast.ClassDef)):
            if any((is_marimo_export_decorator(d) for d in node.decorator_list)):
                if node.name.startswith('test_'):
                    continue
                original_source = ast.get_source_segment(source_code, node)
                lines = original_source.split('\n')
                filtered_lines = []
                for line in lines:
                    stripped = line.strip()
                    if not (stripped.startswith('@app.function') or stripped.startswith('@app.class_definition')):
                        filtered_lines.append(line)
                clean_source = '\n'.join(filtered_lines)
                if docstring_style != 'nbdev':
                    try:
                        docs = extract_param_docs_from_ast(clean_source)
                        formatted_source = build_formatted_docstring(clean_source, docs, docstring_style)
                        exports.append(formatted_source)
                    except Exception as e:
                        print(f'‚ö†Ô∏è  Could not reformat {node.name}: {e}')
                        exports.append(clean_source)
                else:
                    exports.append(clean_source)
                export_names.append(node.name)
    return (setup_metadata, setup_imports, exports, export_names)
</code></pre></details>            </div>
            <div data-signals="{ searchable6: 'extract_mo_md_content m_dev.core source return extract the string content from a mo.md() call, handling r/f/rf string prefixes', matchCount6: 0 }" data-effect="$matchCount6 = [...$tags, $search.trim()].filter(t => t && $searchable6.includes(t.toLowerCase())).length" data-show="($tags.length === 0 && $search.trim().length === 0) || $matchCount6 > 0" data-style-order="($tags.length === 0 && $search.trim().length === 0) ? 6 : -$matchCount6" id="extract_mo_md_content" class="attribute">
<span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount6" class="match-badge" style="display:none;">0</span>              <div class="func-header-right">
<span class="func-module">m_dev.core</span>              </div>
>      extract_mo_md_content (source:str)

*Extract the string content from a mo.md() call, handling r/f/rf string prefixes*<details><summary style="cursor:pointer; margin-top:1rem; color:#2563eb">Source code</summary><pre><code>def extract_mo_md_content(source: str) -&gt; str:
    """Extract the string content from a mo.md() call, handling r/f/rf string prefixes"""
    import re
    pattern = 'mo\\.md\\s*\\(\\s*[rf]*"""(.*?)"""|mo\\.md\\s*\\(\\s*[rf]*\\\'\\\'\\\'(.*?)\\\'\\\'\\\'|mo\\.md\\s*\\(\\s*[rf]*"(.*?)"|mo\\.md\\s*\\(\\s*[rf]*\\\'(.*?)\\\''
    match = re.search(pattern, source, re.DOTALL)
    if match:
        for i in range(1, len(match.groups()) + 1):
            if match.group(i) is not None:
                return match.group(i)
    return ''
</code></pre></details>            </div>
            <div data-signals="{ searchable7: 'extract_param_docs_from_ast m_dev.core func_source return extract parameter docs using ast + tokenizer, no exec needed

args:
    func_source (str): function source code as string

returns:
    dict: dict mapping param names to {'anno': type, 'docment': comment}', matchCount7: 0 }" data-effect="$matchCount7 = [...$tags, $search.trim()].filter(t => t && $searchable7.includes(t.toLowerCase())).length" data-show="($tags.length === 0 && $search.trim().length === 0) || $matchCount7 > 0" data-style-order="($tags.length === 0 && $search.trim().length === 0) ? 7 : -$matchCount7" id="extract_param_docs_from_ast" class="attribute">
<span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount7" class="match-badge" style="display:none;">0</span>              <div class="func-header-right">
<span class="func-module">m_dev.core</span>              </div>
>      extract_param_docs_from_ast (func_source:str)

*Extract parameter docs using AST + tokenizer, no exec needed*

Args:
    func_source (str): Function source code as string

Returns:
    dict: Dict mapping param names to {'anno': type, 'docment': comment}<details><summary style="cursor:pointer; margin-top:1rem; color:#2563eb">Source code</summary><pre><code>def extract_param_docs_from_ast(func_source: str) -&gt; dict:
    """Extract parameter docs using AST + tokenizer, no exec needed

Args:
    func_source (str): Function source code as string

Returns:
    dict: Dict mapping param names to {'anno': type, 'docment': comment}"""
    tree = ast.parse(func_source)
    func_node = tree.body[0]
    param_locs = {}
    for arg in func_node.args.args:
        param_locs[arg.lineno] = {'name': arg.arg, 'anno': ast.unparse(arg.annotation) if arg.annotation else None}
    if func_node.args.vararg:
        param_locs[func_node.args.vararg.lineno] = {'name': func_node.args.vararg.arg, 'anno': None}
    for arg in func_node.args.kwonlyargs:
        param_locs[arg.lineno] = {'name': arg.arg, 'anno': ast.unparse(arg.annotation) if arg.annotation else None}
    if func_node.args.kwarg:
        param_locs[func_node.args.kwarg.lineno] = {'name': func_node.args.kwarg.arg, 'anno': None}
    if func_node.returns:
        param_locs[func_node.returns.lineno] = {'name': 'return', 'anno': ast.unparse(func_node.returns)}
    tokens = tokenize(io.BytesIO(func_source.encode('utf-8')).readline)
    clean_re = re.compile('^\\s*#(.*)\\s*$')
    comments = {}
    for token in tokens:
        if token.type == COMMENT:
            match = clean_re.findall(token.string)
            if match:
                comments[token.start[0]] = match[0].strip()
    result = {}
    for line, param_info in param_locs.items():
        name = param_info['name']
        comment = comments.get(line, '')
        result[name] = {'anno': param_info['anno'], 'docment': comment}
    return result
</code></pre></details>            </div>
            <div data-signals="{ searchable8: 'extract_readme m_dev.core setup_metadata index_path return extract all mo.md() cells from index.py and substitute metadata

args:
    setup_metadata (dict): setup cell metadata for substitution
    index_path (str): path to index notebook file

returns:
    str: path to readme.md or empty string', matchCount8: 0 }" data-effect="$matchCount8 = [...$tags, $search.trim()].filter(t => t && $searchable8.includes(t.toLowerCase())).length" data-show="($tags.length === 0 && $search.trim().length === 0) || $matchCount8 > 0" data-style-order="($tags.length === 0 && $search.trim().length === 0) ? 8 : -$matchCount8" id="extract_readme" class="attribute">
<span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount8" class="match-badge" style="display:none;">0</span>              <div class="func-header-right">
<span class="func-module">m_dev.core</span>              </div>
>      extract_readme (setup_metadata:dict, index_path:str)

*Extract all mo.md() cells from index.py and substitute metadata*

Args:
    setup_metadata (dict): Setup cell metadata for substitution
    index_path (str): Path to index notebook file

Returns:
    str: Path to README.md or empty string<details><summary style="cursor:pointer; margin-top:1rem; color:#2563eb">Source code</summary><pre><code>def extract_readme(setup_metadata: dict, index_path: str) -&gt; str:
    """Extract all mo.md() cells from index.py and substitute metadata

Args:
    setup_metadata (dict): Setup cell metadata for substitution
    index_path (str): Path to index notebook file

Returns:
    str: Path to README.md or empty string"""
    index_path = Path(index_path) if index_path else None
    if not index_path or not index_path.exists():
        print('‚ö†Ô∏è  No index.py found. README.md will not be generated.')
        return ''
    source_code = index_path.read_text()
    md_contents = extract_all_mo_md(source_code)
    if not md_contents:
        print('‚ö†Ô∏è  No mo.md() cells found in index.py')
        return ''
    readme_text = '\n\n'.join(md_contents)
    for key, value in setup_metadata.items():
        readme_text = readme_text.replace(f'{{{key}}}', str(value))
    Path('README.md').write_text(readme_text)
    print('‚úÖ README.md generated from index.py')
    return 'README.md'
</code></pre></details>            </div>
            <div data-signals="{ searchable9: 'format_docments_style m_dev.core func_name params return_info main_doc include_signature return format in docments style (inline comments)

args:
    func_name: name of the function
    params (dict): dictionary of parameter information
    return_info (dict): dictionary of return information
    main_doc (str): main docustring content
    include_signature (bool): whether to include the function signature

returns:
    str: string representation in the target documentation style', matchCount9: 0 }" data-effect="$matchCount9 = [...$tags, $search.trim()].filter(t => t && $searchable9.includes(t.toLowerCase())).length" data-show="($tags.length === 0 && $search.trim().length === 0) || $matchCount9 > 0" data-style-order="($tags.length === 0 && $search.trim().length === 0) ? 9 : -$matchCount9" id="format_docments_style" class="attribute">
<span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount9" class="match-badge" style="display:none;">0</span>              <div class="func-header-right">
<span class="func-module">m_dev.core</span>              </div>
>      format_docments_style (func_name, params:dict, return_info:dict,
>                             main_doc:str, include_signature:bool)

*Format in docments style (inline comments)*

Args:
    func_name: Name of the function
    params (dict): Dictionary of parameter information
    return_info (dict): Dictionary of return information
    main_doc (str): Main Docustring content
    include_signature (bool): whether to include the function signature

Returns:
    str: String representation in the target documentation style<details><summary style="cursor:pointer; margin-top:1rem; color:#2563eb">Source code</summary><pre><code>def format_docments_style(func_name, params: dict, return_info: dict, main_doc: str, include_signature: bool) -&gt; str:
    """Format in docments style (inline comments)

Args:
    func_name: Name of the function
    params (dict): Dictionary of parameter information
    return_info (dict): Dictionary of return information
    main_doc (str): Main Docustring content
    include_signature (bool): whether to include the function signature

Returns:
    str: String representation in the target documentation style"""
    lines = [f'def {func_name}(']
    for i, (name, info) in enumerate(params.items()):
        anno = f":{info['anno'].__name__}" if info['anno'] != empty and hasattr(info['anno'], '__name__') else ''
        default = f"={repr(info['default'])}" if info['default'] != empty else ''
        comment = f"  # {info['docment']}" if info['docment'] and info['docment'] != empty else ''
        comma = ',' if i &lt; len(params) - 1 else ''
        lines.append(f'    {name}{anno}{default}{comma}{comment}')
    ret_anno = f"-&gt;{return_info['anno'].__name__}" if return_info.get('anno') != empty and hasattr(return_info.get('anno'), '__name__') else ''
    ret_comment = f"  # {return_info['docment']}" if return_info.get('docment') and return_info['docment'] != empty else ''
    lines.append(f'){ret_anno}:{ret_comment}')
    if main_doc:
        lines.append(f'    "{main_doc}"')
    return '\n'.join(lines)
</code></pre></details>            </div>
            <div data-signals="{ searchable10: 'format_google_style m_dev.core func_name params return_info main_doc include_signature sig return format in google style

args:
    func_name: name of the function
    params: dictionary of parameter information
    return_info: dictionary of return information
    main_doc: main docstring content
    include_signature (bool): whether to include the function signature
    sig: function signature object

returns:
    str: formatted string in google style', matchCount10: 0 }" data-effect="$matchCount10 = [...$tags, $search.trim()].filter(t => t && $searchable10.includes(t.toLowerCase())).length" data-show="($tags.length === 0 && $search.trim().length === 0) || $matchCount10 > 0" data-style-order="($tags.length === 0 && $search.trim().length === 0) ? 10 : -$matchCount10" id="format_google_style" class="attribute">
<span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount10" class="match-badge" style="display:none;">0</span>              <div class="func-header-right">
<span class="func-module">m_dev.core</span>              </div>
>      format_google_style (func_name, params, return_info, main_doc,
>                           include_signature:bool, sig)

*Format in Google style*

Args:
    func_name: Name of the function
    params: Dictionary of parameter information
    return_info: Dictionary of return information
    main_doc: Main docstring content
    include_signature (bool): Whether to include the function signature
    sig: Function signature object

Returns:
    str: Formatted string in Google style<details><summary style="cursor:pointer; margin-top:1rem; color:#2563eb">Source code</summary><pre><code>def format_google_style(func_name, params, return_info, main_doc, include_signature: bool, sig) -&gt; str:
    """Format in Google style

Args:
    func_name: Name of the function
    params: Dictionary of parameter information
    return_info: Dictionary of return information
    main_doc: Main docstring content
    include_signature (bool): Whether to include the function signature
    sig: Function signature object

Returns:
    str: Formatted string in Google style"""
    lines = []
    if include_signature:
        lines.append(f'def {func_name}{sig}:')
    lines.append('    """' + (main_doc or ''))
    lines.append('')
    if params:
        lines.append('    Args:')
        for name, info in params.items():
            type_str = f" ({info['anno'].__name__})" if info['anno'] != empty and hasattr(info['anno'], '__name__') else ''
            default_str = f", optional, default={repr(info['default'])}" if info['default'] != empty else ''
            desc = info.get('docment', '') or ''
            lines.append(f'        {name}{type_str}: {desc}{default_str}')
        lines.append('')
    if return_info.get('anno') != empty or return_info.get('docment'):
        lines.append('    Returns:')
        ret_type = return_info.get('anno')
        type_str = f'{ret_type.__name__}: ' if ret_type != empty and hasattr(ret_type, '__name__') else ''
        ret_desc = return_info.get('docment', '') or ''
        lines.append(f'        {type_str}{ret_desc}')
    lines.append('    """')
    return '\n'.join(lines)
</code></pre></details>            </div>
            <div data-signals="{ searchable11: 'format_numpy_style m_dev.core func_name params return_info main_doc include_signature sig return format in numpy style

args:
    func_name: name of the function
    params: dictionary of parameter information
    return_info: dictionary of return information
    main_doc: main docstring content
    include_signature (bool): whether to include the function signature
    sig: function signature object

returns:
    str: formatted string in numpy style', matchCount11: 0 }" data-effect="$matchCount11 = [...$tags, $search.trim()].filter(t => t && $searchable11.includes(t.toLowerCase())).length" data-show="($tags.length === 0 && $search.trim().length === 0) || $matchCount11 > 0" data-style-order="($tags.length === 0 && $search.trim().length === 0) ? 11 : -$matchCount11" id="format_numpy_style" class="attribute">
<span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount11" class="match-badge" style="display:none;">0</span>              <div class="func-header-right">
<span class="func-module">m_dev.core</span>              </div>
>      format_numpy_style (func_name, params, return_info, main_doc,
>                          include_signature:bool, sig)

*Format in NumPy style*

Args:
    func_name: Name of the function
    params: Dictionary of parameter information
    return_info: Dictionary of return information
    main_doc: Main docstring content
    include_signature (bool): Whether to include the function signature
    sig: Function signature object

Returns:
    str: Formatted string in NumPy style<details><summary style="cursor:pointer; margin-top:1rem; color:#2563eb">Source code</summary><pre><code>def format_numpy_style(func_name, params, return_info, main_doc, include_signature: bool, sig) -&gt; str:
    """Format in NumPy style

Args:
    func_name: Name of the function
    params: Dictionary of parameter information
    return_info: Dictionary of return information
    main_doc: Main docstring content
    include_signature (bool): Whether to include the function signature
    sig: Function signature object

Returns:
    str: Formatted string in NumPy style"""
    lines = []
    if include_signature:
        lines.append(f'def {func_name}{sig}:')
    lines.append('    """' + (main_doc or ''))
    lines.append('')
    if params:
        lines.append('    Parameters')
        lines.append('    ----------')
        for name, info in params.items():
            type_str = info['anno'].__name__ if info['anno'] != empty and hasattr(info['anno'], '__name__') else ''
            lines.append(f'    {name} : {type_str}')
            desc = info.get('docment', '') or ''
            if desc:
                for desc_line in desc.split('\n'):
                    lines.append(f'        {desc_line}')
            if info['default'] != empty:
                lines.append(f"        (default: {repr(info['default'])})")
        lines.append('')
    if return_info.get('anno') != empty or return_info.get('docment'):
        lines.append('    Returns')
        lines.append('    -------')
        ret_type = return_info.get('anno')
        type_str = ret_type.__name__ if ret_type != empty and hasattr(ret_type, '__name__') else ''
        lines.append(f'    {type_str}')
        ret_desc = return_info.get('docment', '') or ''
        if ret_desc:
            for desc_line in ret_desc.split('\n'):
                lines.append(f'        {desc_line}')
    lines.append('    """')
    return '\n'.join(lines)
</code></pre></details>            </div>
            <div data-signals="{ searchable12: 'is_marimo_export_decorator m_dev.core decorator return check if decorator is app.function or app.class_definition (with or without args)

args:
    decorator: the decorator that marimo attached to the cell

returns:
    bool: true if the function or cell is reusable - should match marimos detection', matchCount12: 0 }" data-effect="$matchCount12 = [...$tags, $search.trim()].filter(t => t && $searchable12.includes(t.toLowerCase())).length" data-show="($tags.length === 0 && $search.trim().length === 0) || $matchCount12 > 0" data-style-order="($tags.length === 0 && $search.trim().length === 0) ? 12 : -$matchCount12" id="is_marimo_export_decorator" class="attribute">
<span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount12" class="match-badge" style="display:none;">0</span>              <div class="func-header-right">
<span class="func-module">m_dev.core</span>              </div>
>      is_marimo_export_decorator (decorator)

*Check if decorator is app.function or app.class_definition (with or without args)*

Args:
    decorator: the decorator that marimo attached to the cell

Returns:
    bool: True if the function or cell is reusable - should match marimos detection<details><summary style="cursor:pointer; margin-top:1rem; color:#2563eb">Source code</summary><pre><code>def is_marimo_export_decorator(decorator) -&gt; bool:
    """Check if decorator is app.function or app.class_definition (with or without args)

Args:
    decorator: the decorator that marimo attached to the cell

Returns:
    bool: True if the function or cell is reusable - should match marimos detection"""
    if isinstance(decorator, ast.Call):
        decorator_name = ast.unparse(decorator.func)
    else:
        decorator_name = ast.unparse(decorator)
    return decorator_name in ['app.function', 'app.class_definition']
</code></pre></details>            </div>
            <div data-signals="{ searchable13: 'old_write_init m_dev.core package_name metadata modules output_file return write package __init__.py with metadata and cross-module imports

args:
    package_name (str): package name
    metadata (dict): project metadata from setup cell
    modules (list): list of module dicts from scan_notebooks
    output_file (str): path to __init__.py

returns:
    str: path to written file', matchCount13: 0 }" data-effect="$matchCount13 = [...$tags, $search.trim()].filter(t => t && $searchable13.includes(t.toLowerCase())).length" data-show="($tags.length === 0 && $search.trim().length === 0) || $matchCount13 > 0" data-style-order="($tags.length === 0 && $search.trim().length === 0) ? 13 : -$matchCount13" id="old_write_init" class="attribute">
<span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount13" class="match-badge" style="display:none;">0</span>              <div class="func-header-right">
<span class="func-module">m_dev.core</span>              </div>
>      old_write_init (package_name:str, metadata:dict, modules:list,
>                      output_file:str)

*Write package __init__.py with metadata and cross-module imports*

Args:
    package_name (str): Package name
    metadata (dict): Project metadata from setup cell
    modules (list): List of module dicts from scan_notebooks
    output_file (str): Path to __init__.py

Returns:
    str: Path to written file<details><summary style="cursor:pointer; margin-top:1rem; color:#2563eb">Source code</summary><pre><code>def old_write_init(package_name: str, metadata: dict, modules: list, output_file: str) -&gt; str:
    """Write package __init__.py with metadata and cross-module imports

Args:
    package_name (str): Package name
    metadata (dict): Project metadata from setup cell
    modules (list): List of module dicts from scan_notebooks
    output_file (str): Path to __init__.py

Returns:
    str: Path to written file"""
    with Path(output_file).open('w') as f:
        description = metadata.get('__description__', 'No description provided')
        f.write(f'"""{description}"""\n\n')
        f.write(f"__version__ = '{metadata['__version__']}'\n")
        if '__author__' in metadata:
            author_name = metadata['__author__'].split('&lt;')[0].strip()
            f.write(f"__author__ = '{author_name}'\n")
        f.write('\n')
        all_exports = []
        for module in modules:
            if module['name'].startswith('00_') or not module['export_names']:
                continue
            if module['export_names']:
                exports_str = ', '.join(module['export_names'])
                f.write(f"from {module['name']} import {exports_str}\n")
                all_exports.extend(module['export_names'])
        if all_exports:
            f.write('\n')
            f.write('__all__ = [\n')
            for name in all_exports:
                f.write(f'    "{name}",\n')
            f.write(']\n')
    print(f'‚úÖ Generated {output_file}')
    return output_file
</code></pre></details>            </div>
            <div data-signals="{ searchable14: 'scan_notebooks m_dev.core notebooks_dir docstring_style return scan notebooks directory and extract all exports, metadata, and readme

args:
    notebooks_dir (str): directory containing notebook files
    docstring_style (str): docstring style for all exports

returns:
    scanresult: a typed dict with the described structure.', matchCount14: 0 }" data-effect="$matchCount14 = [...$tags, $search.trim()].filter(t => t && $searchable14.includes(t.toLowerCase())).length" data-show="($tags.length === 0 && $search.trim().length === 0) || $matchCount14 > 0" data-style-order="($tags.length === 0 && $search.trim().length === 0) ? 14 : -$matchCount14" id="scan_notebooks" class="attribute">
<span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount14" class="match-badge" style="display:none;">0</span>              <div class="func-header-right">
<span class="func-module">m_dev.core</span>              </div>
>      scan_notebooks (notebooks_dir:str='notebooks',
>                      docstring_style:str='nbdev')

*Scan notebooks directory and extract all exports, metadata, and README*

Args:
    notebooks_dir (str): Directory containing notebook files
    docstring_style (str): Docstring style for all exports

Returns:
    ScanResult: A typed dict with the described structure.<details><summary style="cursor:pointer; margin-top:1rem; color:#2563eb">Source code</summary><pre><code>def scan_notebooks(notebooks_dir: str='notebooks', docstring_style: str='nbdev') -&gt; ScanResult:
    """Scan notebooks directory and extract all exports, metadata, and README

Args:
    notebooks_dir (str): Directory containing notebook files
    docstring_style (str): Docstring style for all exports

Returns:
    ScanResult: A typed dict with the described structure."""
    notebooks_path = Path(notebooks_dir)
    if not notebooks_path.exists():
        raise ValueError(f"Notebooks directory '{notebooks_dir}' does not exist")
    notebook_files = sorted(notebooks_path.glob('*.py'))
    if not notebook_files:
        raise ValueError(f"No .py files found in '{notebooks_dir}'")
    metadata = None
    metadata_found_in = None
    index_path = None
    modules = []
    for notebook_file in notebook_files:
        if notebook_file.name.startswith('.') or notebook_file.name == '__pycache__':
            continue
        nb_metadata, setup_imports, exports, export_names = extract_exports(str(notebook_file), docstring_style)
        if nb_metadata:
            if metadata_found_in:
                raise ValueError(f'Project metadata defined in multiple notebooks:\n  - {metadata_found_in}\n  - {notebook_file.name}\nMetadata should only be defined in one notebook (typically 00_index or index.py)')
            metadata = nb_metadata
            metadata_found_in = notebook_file.name
            index_path = str(notebook_file)
        module_name = re.sub('^\\d+_', '', notebook_file.stem)
        modules.append({'name': module_name, 'imports': setup_imports, 'exports': exports, 'export_names': export_names})
    if not metadata:
        raise ValueError(f"No project metadata found in any notebook.\nAdd metadata to your config notebook (e.g., 00_index.py) in the setup cell:\n    __version__ = '0.1.0'\n    __description__ = 'My package'\n    __author__ = 'Name &lt;email@example.com&gt;'\n    __license__ = 'MIT'")
    return {'metadata': metadata, 'modules': modules, 'index_path': index_path}
</code></pre></details>            </div>
            <div data-signals="{ searchable15: 'update_pyproject_toml m_dev.core setup_metadata pyproject_path return update pyproject.toml with metadata from notebook setup cell

args:
    setup_metadata (dict): package metadata from setup cell
    pyproject_path (str): path to pyproject.toml

returns:
    str: path to updated file', matchCount15: 0 }" data-effect="$matchCount15 = [...$tags, $search.trim()].filter(t => t && $searchable15.includes(t.toLowerCase())).length" data-show="($tags.length === 0 && $search.trim().length === 0) || $matchCount15 > 0" data-style-order="($tags.length === 0 && $search.trim().length === 0) ? 15 : -$matchCount15" id="update_pyproject_toml" class="attribute">
<span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount15" class="match-badge" style="display:none;">0</span>              <div class="func-header-right">
<span class="func-module">m_dev.core</span>              </div>
>      update_pyproject_toml (setup_metadata:dict,
>                             pyproject_path:str='pyproject.toml')

*Update pyproject.toml with metadata from notebook setup cell*

Args:
    setup_metadata (dict): Package metadata from setup cell
    pyproject_path (str): Path to pyproject.toml

Returns:
    str: Path to updated file<details><summary style="cursor:pointer; margin-top:1rem; color:#2563eb">Source code</summary><pre><code>def update_pyproject_toml(setup_metadata: dict, pyproject_path: str='pyproject.toml') -&gt; str:
    """Update pyproject.toml with metadata from notebook setup cell

Args:
    setup_metadata (dict): Package metadata from setup cell
    pyproject_path (str): Path to pyproject.toml

Returns:
    str: Path to updated file"""
    validate_setup_metadata(setup_metadata)
    with open(pyproject_path, 'rb') as f:
        config = tomllib.load(f)
    if 'project' not in config:
        config['project'] = {}
    config['project']['version'] = setup_metadata['__version__']
    config['project']['description'] = setup_metadata['__description__']
    config['project']['license'] = {'text': setup_metadata['__license__']}
    author_name = setup_metadata['__author__'].split('&lt;')[0].strip()
    author_email = setup_metadata['__author__'].split('&lt;')[1].strip('&gt;')
    config['project']['authors'] = [{'name': author_name, 'email': author_email}]
    if '__keywords__' in setup_metadata and setup_metadata['__keywords__']:
        config['project']['keywords'] = setup_metadata['__keywords__']
    if '__classifiers__' in setup_metadata and setup_metadata['__classifiers__']:
        config['project']['classifiers'] = setup_metadata['__classifiers__']
    if any((k in setup_metadata for k in ['__repository__', '__homepage__', '__documentation__'])):
        config['project']['urls'] = {}
        if '__repository__' in setup_metadata:
            config['project']['urls']['Repository'] = setup_metadata['__repository__']
        if '__homepage__' in setup_metadata:
            config['project']['urls']['Homepage'] = setup_metadata['__homepage__']
        if '__documentation__' in setup_metadata:
            config['project']['urls']['Documentation'] = setup_metadata['__documentation__']
    try:
        import tomlkit
        with open(pyproject_path, 'r') as f:
            doc = tomlkit.load(f)
        if 'project' not in doc:
            doc['project'] = {}
        doc['project']['version'] = setup_metadata['__version__']
        doc['project']['description'] = setup_metadata['__description__']
        doc['project']['license'] = {'text': setup_metadata['__license__']}
        doc['project']['authors'] = [{'name': author_name, 'email': author_email}]
        if '__keywords__' in setup_metadata and setup_metadata['__keywords__']:
            doc['project']['keywords'] = setup_metadata['__keywords__']
        if '__classifiers__' in setup_metadata and setup_metadata['__classifiers__']:
            doc['project']['classifiers'] = setup_metadata['__classifiers__']
        if any((k in setup_metadata for k in ['__repository__', '__homepage__', '__documentation__'])):
            if 'urls' not in doc['project']:
                doc['project']['urls'] = {}
            if '__repository__' in setup_metadata:
                doc['project']['urls']['Repository'] = setup_metadata['__repository__']
            if '__homepage__' in setup_metadata:
                doc['project']['urls']['Homepage'] = setup_metadata['__homepage__']
            if '__documentation__' in setup_metadata:
                doc['project']['urls']['Documentation'] = setup_metadata['__documentation__']
        with open(pyproject_path, 'w') as f:
            tomlkit.dump(doc, f)
    except ImportError:
        print('‚ö†Ô∏è  tomlkit not available, using basic TOML writing')
        import json
        with open(pyproject_path, 'a') as f:
            f.write(f'\n# Updated by m-dev\n')
    print(f'‚úÖ Updated {pyproject_path} with metadata')
    return pyproject_path
</code></pre></details>            </div>
            <div data-signals="{ searchable16: 'validate_setup_metadata m_dev.core setup_metadata return validate that required metadata keys exist and have valid values for package generation

args:
    setup_metadata (dict): package metadata from setup cell

returns:
    none: raises valueerror if invalid', matchCount16: 0 }" data-effect="$matchCount16 = [...$tags, $search.trim()].filter(t => t && $searchable16.includes(t.toLowerCase())).length" data-show="($tags.length === 0 && $search.trim().length === 0) || $matchCount16 > 0" data-style-order="($tags.length === 0 && $search.trim().length === 0) ? 16 : -$matchCount16" id="validate_setup_metadata" class="attribute">
<span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount16" class="match-badge" style="display:none;">0</span>              <div class="func-header-right">
<span class="func-module">m_dev.core</span>              </div>
>      validate_setup_metadata (setup_metadata:dict)

*Validate that required metadata keys exist and have valid values for package generation*

Args:
    setup_metadata (dict): Package metadata from setup cell

Returns:
    None: Raises ValueError if invalid<details><summary style="cursor:pointer; margin-top:1rem; color:#2563eb">Source code</summary><pre><code>def validate_setup_metadata(setup_metadata: dict) -&gt; None:
    """Validate that required metadata keys exist and have valid values for package generation

Args:
    setup_metadata (dict): Package metadata from setup cell

Returns:
    None: Raises ValueError if invalid"""
    required = ['__version__', '__description__', '__author__', '__license__']
    missing = [k for k in required if k not in setup_metadata]
    if missing:
        raise ValueError(f"Setup cell missing required metadata: {', '.join(missing)}\n\nAdd these to your setup cell:\n" + '\n'.join([f"    {k} = '...'" for k in missing]))
    version = setup_metadata['__version__']
    if not version or not version.strip():
        raise ValueError('__version__ cannot be empty')
    desc = setup_metadata['__description__']
    if not desc or not desc.strip():
        raise ValueError('__description__ cannot be empty')
    author = setup_metadata['__author__']
    if not author or not author.strip():
        raise ValueError('__author__ cannot be empty')
    if '&lt;' not in author or '&gt;' not in author:
        raise ValueError("__author__ must be in format 'Name &lt;email@example.com&gt;'")
    email_part = author.split('&lt;')[1].split('&gt;')[0].strip()
    if not email_part or '@' not in email_part:
        raise ValueError(f"__author__ email '{email_part}' is not valid")
    license_val = setup_metadata['__license__']
    if not license_val or not license_val.strip():
        raise ValueError('__license__ cannot be empty')
</code></pre></details>            </div>
            <div data-signals="{ searchable17: 'write_init m_dev.core package_name metadata modules output_file return write package __init__.py with metadata and cross-module imports

args:
    package_name (str): package name
    metadata (dict): project metadata from setup cell
    modules (list): list of module dicts from scan_notebooks
    output_file (str): path to __init__.py

returns:
    str: path to written file', matchCount17: 0 }" data-effect="$matchCount17 = [...$tags, $search.trim()].filter(t => t && $searchable17.includes(t.toLowerCase())).length" data-show="($tags.length === 0 && $search.trim().length === 0) || $matchCount17 > 0" data-style-order="($tags.length === 0 && $search.trim().length === 0) ? 17 : -$matchCount17" id="write_init" class="attribute">
<span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount17" class="match-badge" style="display:none;">0</span>              <div class="func-header-right">
<span class="func-module">m_dev.core</span>              </div>
>      write_init (package_name:str, metadata:dict, modules:list,
>                  output_file:str)

*Write package __init__.py with metadata and cross-module imports*

Args:
    package_name (str): Package name
    metadata (dict): Project metadata from setup cell
    modules (list): List of module dicts from scan_notebooks
    output_file (str): Path to __init__.py

Returns:
    str: Path to written file<details><summary style="cursor:pointer; margin-top:1rem; color:#2563eb">Source code</summary><pre><code>def write_init(package_name: str, metadata: dict, modules: list, output_file: str) -&gt; str:
    """Write package __init__.py with metadata and cross-module imports

Args:
    package_name (str): Package name
    metadata (dict): Project metadata from setup cell
    modules (list): List of module dicts from scan_notebooks
    output_file (str): Path to __init__.py

Returns:
    str: Path to written file"""
    with Path(output_file).open('w') as f:
        description = metadata.get('__description__', 'No description provided')
        f.write(f'"""{description}"""\n\n')
        f.write(f"__version__ = '{metadata['__version__']}'\n")
        if '__author__' in metadata:
            author_name = metadata['__author__'].split('&lt;')[0].strip()
            f.write(f"__author__ = '{author_name}'\n")
        f.write('\n')
        all_exports = []
        for module in modules:
            if module['name'].startswith('00_') or not module['export_names']:
                continue
            if module['export_names']:
                exports_str = ', '.join(module['export_names'])
                f.write(f"from .{module['name']} import {exports_str}\n")
                all_exports.extend(module['export_names'])
        if all_exports:
            f.write('\n')
            f.write('__all__ = [\n')
            for name in all_exports:
                f.write(f'    "{name}",\n')
            f.write(']\n')
    print(f'‚úÖ Generated {output_file}')
    return output_file
</code></pre></details>            </div>
            <div data-signals="{ searchable18: 'write_module m_dev.core module_name setup_imports exports output_file return write python module file with imports and exported code

args:
    module_name (str): name of the module (without .py)
    setup_imports (list): import statements from setup cell
    exports (list): exported function/class source code
    output_file (str): path for output file

returns:
    str: path to written file', matchCount18: 0 }" data-effect="$matchCount18 = [...$tags, $search.trim()].filter(t => t && $searchable18.includes(t.toLowerCase())).length" data-show="($tags.length === 0 && $search.trim().length === 0) || $matchCount18 > 0" data-style-order="($tags.length === 0 && $search.trim().length === 0) ? 18 : -$matchCount18" id="write_module" class="attribute">
<span data-show="$tags.length > 0 || $search.trim().length > 0" data-text="$matchCount18" class="match-badge" style="display:none;">0</span>              <div class="func-header-right">
<span class="func-module">m_dev.core</span>              </div>
>      write_module (module_name:str, setup_imports:list, exports:list,
>                    output_file:str)

*Write Python module file with imports and exported code*

Args:
    module_name (str): Name of the module (without .py)
    setup_imports (list): Import statements from setup cell
    exports (list): Exported function/class source code
    output_file (str): Path for output file

Returns:
    str: Path to written file<details><summary style="cursor:pointer; margin-top:1rem; color:#2563eb">Source code</summary><pre><code>def write_module(module_name: str, setup_imports: list, exports: list, output_file: str) -&gt; str:
    """Write Python module file with imports and exported code

Args:
    module_name (str): Name of the module (without .py)
    setup_imports (list): Import statements from setup cell
    exports (list): Exported function/class source code
    output_file (str): Path for output file

Returns:
    str: Path to written file"""
    with Path(output_file).open('w') as f:
        if setup_imports:
            for imp in setup_imports:
                f.write(imp + '\n')
            f.write('\n')
        for export in exports:
            f.write(export + '\n\n')
    return output_file
</code></pre></details>            </div>
          </div>
        </div>
      </div>
    </body>
  </body>
</html>
